//
// Generated file, do not edit! Created by opp_msgtool 6.0 from simnet/mod/Packet.msg.
//

#ifndef __PACKET_M_H
#define __PACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class EthernetMacHeader;
class IpHeader;
class UdpHeader;
class TcpLikeHeader;
class Packet;
class AggPacket;
class ATPPacket;
class MTATPPacket;
/**
 * Enum generated from <tt>simnet/mod/Packet.msg:2</tt> by opp_msgtool.
 * <pre>
 * enum PacketType
 * {
 *     ACK = 0;
 *     DATA = 1;
 *     AGG = 2;
 *     REMIND = 3;
 *     NOUSE = 4;
 * }
 * </pre>
 */
enum PacketType {
    ACK = 0,
    DATA = 1,
    AGG = 2,
    REMIND = 3,
    NOUSE = 4
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PacketType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PacketType& e) { int n; b->unpack(n); e = static_cast<PacketType>(n); }

/**
 * Enum generated from <tt>simnet/mod/Packet.msg:11</tt> by opp_msgtool.
 * <pre>
 * enum AggPolicy
 * {
 *     ATP = 0;
 *     MTATP = 1;
 * }
 * </pre>
 */
enum AggPolicy {
    ATP = 0,
    MTATP = 1
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const AggPolicy& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, AggPolicy& e) { int n; b->unpack(n); e = static_cast<AggPolicy>(n); }

/**
 * Class generated from <tt>simnet/mod/Packet.msg:17</tt> by opp_msgtool.
 * <pre>
 * packet EthernetMacHeader
 * {
 *     byteLength = 14;
 * }
 * </pre>
 */
class EthernetMacHeader : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const EthernetMacHeader& other);

  protected:
    bool operator==(const EthernetMacHeader&) = delete;

  public:
    EthernetMacHeader(const char *name=nullptr, short kind=0);
    EthernetMacHeader(const EthernetMacHeader& other);
    virtual ~EthernetMacHeader();
    EthernetMacHeader& operator=(const EthernetMacHeader& other);
    virtual EthernetMacHeader *dup() const override {return new EthernetMacHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EthernetMacHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EthernetMacHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:22</tt> by opp_msgtool.
 * <pre>
 * class IpHeader extends EthernetMacHeader
 * {
 *     byteLength = 14 + 20;
 *     int64_t srcAddr;
 *     int64_t destAddr;
 * }
 * </pre>
 */
class IpHeader : public ::EthernetMacHeader
{
  protected:
    int64_t srcAddr = 0;
    int64_t destAddr = 0;

  private:
    void copy(const IpHeader& other);

  protected:
    bool operator==(const IpHeader&) = delete;

  public:
    IpHeader(const char *name=nullptr);
    IpHeader(const IpHeader& other);
    virtual ~IpHeader();
    IpHeader& operator=(const IpHeader& other);
    virtual IpHeader *dup() const override {return new IpHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int64_t getSrcAddr() const;
    virtual void setSrcAddr(int64_t srcAddr);

    virtual int64_t getDestAddr() const;
    virtual void setDestAddr(int64_t destAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IpHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IpHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:29</tt> by opp_msgtool.
 * <pre>
 * class UdpHeader extends IpHeader
 * {
 *     byteLength = 14 + 20 + 8;
 *     uint16_t localPort;
 *     uint16_t destPort;
 * }
 * </pre>
 */
class UdpHeader : public ::IpHeader
{
  protected:
    uint16_t localPort = 0;
    uint16_t destPort = 0;

  private:
    void copy(const UdpHeader& other);

  protected:
    bool operator==(const UdpHeader&) = delete;

  public:
    UdpHeader(const char *name=nullptr);
    UdpHeader(const UdpHeader& other);
    virtual ~UdpHeader();
    UdpHeader& operator=(const UdpHeader& other);
    virtual UdpHeader *dup() const override {return new UdpHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint16_t getLocalPort() const;
    virtual void setLocalPort(uint16_t localPort);

    virtual uint16_t getDestPort() const;
    virtual void setDestPort(uint16_t destPort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:36</tt> by opp_msgtool.
 * <pre>
 * class TcpLikeHeader extends IpHeader
 * {
 *     // ! do not use this class directly, it has no size
 *     int64_t seqNumber;
 *     uint16_t localPort;
 *     uint16_t destPort;
 *     bool ECN;
 *     bool ECE;
 * }
 * </pre>
 */
class TcpLikeHeader : public ::IpHeader
{
  protected:
    int64_t seqNumber = 0;
    uint16_t localPort = 0;
    uint16_t destPort = 0;
    bool ECN = false;
    bool ECE = false;

  private:
    void copy(const TcpLikeHeader& other);

  protected:
    bool operator==(const TcpLikeHeader&) = delete;

  public:
    TcpLikeHeader(const char *name=nullptr);
    TcpLikeHeader(const TcpLikeHeader& other);
    virtual ~TcpLikeHeader();
    TcpLikeHeader& operator=(const TcpLikeHeader& other);
    virtual TcpLikeHeader *dup() const override {return new TcpLikeHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int64_t getSeqNumber() const;
    virtual void setSeqNumber(int64_t seqNumber);

    virtual uint16_t getLocalPort() const;
    virtual void setLocalPort(uint16_t localPort);

    virtual uint16_t getDestPort() const;
    virtual void setDestPort(uint16_t destPort);

    virtual bool getECN() const;
    virtual void setECN(bool ECN);

    virtual bool getECE() const;
    virtual void setECE(bool ECE);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TcpLikeHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TcpLikeHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:46</tt> by opp_msgtool.
 * <pre>
 * class Packet extends TcpLikeHeader
 * {
 *     // cheating fields
 *     PacketType packetType;
 *     int64_t connectionId;
 *     int64_t receivedBytes;
 *     double startTime;
 *     double transmitTime;
 *     double queueTime;
 *     bool isFlowFinished;
 * }
 * </pre>
 */
class Packet : public ::TcpLikeHeader
{
  protected:
    PacketType packetType = static_cast<PacketType>(-1);
    int64_t connectionId = 0;
    int64_t receivedBytes = 0;
    double startTime = 0;
    double transmitTime = 0;
    double queueTime = 0;
    bool isFlowFinished_ = false;

  private:
    void copy(const Packet& other);

  protected:
    bool operator==(const Packet&) = delete;

  public:
    Packet(const char *name=nullptr);
    Packet(const Packet& other);
    virtual ~Packet();
    Packet& operator=(const Packet& other);
    virtual Packet *dup() const override {return new Packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual PacketType getPacketType() const;
    virtual void setPacketType(PacketType packetType);

    virtual int64_t getConnectionId() const;
    virtual void setConnectionId(int64_t connectionId);

    virtual int64_t getReceivedBytes() const;
    virtual void setReceivedBytes(int64_t receivedBytes);

    virtual double getStartTime() const;
    virtual void setStartTime(double startTime);

    virtual double getTransmitTime() const;
    virtual void setTransmitTime(double transmitTime);

    virtual double getQueueTime() const;
    virtual void setQueueTime(double queueTime);

    virtual bool isFlowFinished() const;
    virtual void setIsFlowFinished(bool isFlowFinished);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Packet& obj) {obj.parsimUnpack(b);}

// cplusplus {{
#include <vector>
// }}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:62</tt> by opp_msgtool.
 * <pre>
 * class AggPacket extends Packet
 * {
 *     packetType = AGG;
 *     AggPolicy aggPolicy;
 *     int round;
 *     int aggregatorIndex;
 *     int64_t jobId;
 *     int workerNumber;
 *     bool overflow;
 *     bool resend;
 *     bool collision;
 *     bool ecn;
 *     bool isAck;
 *     // cheating fields
 *     int64_t workerRecord[] \@custom \@sizeGetter(getRecordLen) \@sizeSetter(setRecordLen) \@getter(getRecord) \@setter(setRecord);
 * }
 * </pre>
 */
class AggPacket : public ::Packet
{
  protected:
    AggPolicy aggPolicy = static_cast<AggPolicy>(-1);
    int round = 0;
    int aggregatorIndex = 0;
    int64_t jobId = 0;
    int workerNumber = 0;
    bool overflow = false;
    bool resend = false;
    bool collision = false;
    bool ecn = false;
    bool isAck_ = false;

  private:
    void copy(const AggPacket& other);

  protected:
    bool operator==(const AggPacket&) = delete;

  public:
    AggPacket(const char *name=nullptr);
    AggPacket(const AggPacket& other);
    virtual ~AggPacket();
    AggPacket& operator=(const AggPacket& other);
    virtual AggPacket *dup() const override {return new AggPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual AggPolicy getAggPolicy() const;
    virtual void setAggPolicy(AggPolicy aggPolicy);

    virtual int getRound() const;
    virtual void setRound(int round);

    virtual int getAggregatorIndex() const;
    virtual void setAggregatorIndex(int aggregatorIndex);

    virtual int64_t getJobId() const;
    virtual void setJobId(int64_t jobId);

    virtual int getWorkerNumber() const;
    virtual void setWorkerNumber(int workerNumber);

    virtual bool getOverflow() const;
    virtual void setOverflow(bool overflow);

    virtual bool getResend() const;
    virtual void setResend(bool resend);

    virtual bool getCollision() const;
    virtual void setCollision(bool collision);

    virtual bool getEcn() const;
    virtual void setEcn(bool ecn);

    virtual bool isAck() const;
    virtual void setIsAck(bool isAck);


    protected:
        std::vector<int64_t> workerRecord;
    public:
        // expected methods:
        virtual void setRecordLen(size_t size) {
            workerRecord.reserve(size);
        }
        virtual size_t getRecordLen() const {return workerRecord.size();}
        virtual std::vector<int64_t> getRecord() const {return workerRecord;}
        virtual int64_t getRecord(size_t k) {return workerRecord.at(k);}
        virtual void setRecord(size_t k, int64_t worker) {
            EV_WARN << "You should not use this method, but using addRecord instead." << std::endl;
            workerRecord[k] = worker;
        }
        //new methods:
        virtual void addRecord(int64_t worker) {
            workerRecord.push_back(worker);
        }
        virtual void setRecord(std::vector<int64_t>& workers) {
            auto oldLen = getRecordLen();
            for (auto i = 0; i < oldLen; i++) {
                workerRecord[i] = workers.back();
                workers.pop_back();
            }
            while (!workers.empty()) {
                workerRecord.push_back(workers.back());
                workers.pop_back();
            }
        }
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const AggPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, AggPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:118</tt> by opp_msgtool.
 * <pre>
 * class ATPPacket extends AggPacket
 * {
 *     aggPolicy = ATP;
 *     byteLength = 16 + 8; // ATP header total size is 58 Bytes
 *     uint32_t bitmap0;
 *     uint32_t bitmap1;
 *     int fanIndegree0;
 *     int fanIndegree1;
 *     int switchIdentifier;
 * }
 * </pre>
 */
class ATPPacket : public ::AggPacket
{
  protected:
    uint32_t bitmap0 = 0;
    uint32_t bitmap1 = 0;
    int fanIndegree0 = 0;
    int fanIndegree1 = 0;
    int switchIdentifier = 0;

  private:
    void copy(const ATPPacket& other);

  protected:
    bool operator==(const ATPPacket&) = delete;

  public:
    ATPPacket(const char *name=nullptr);
    ATPPacket(const ATPPacket& other);
    virtual ~ATPPacket();
    ATPPacket& operator=(const ATPPacket& other);
    virtual ATPPacket *dup() const override {return new ATPPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getBitmap0() const;
    virtual void setBitmap0(uint32_t bitmap0);

    virtual uint32_t getBitmap1() const;
    virtual void setBitmap1(uint32_t bitmap1);

    virtual int getFanIndegree0() const;
    virtual void setFanIndegree0(int fanIndegree0);

    virtual int getFanIndegree1() const;
    virtual void setFanIndegree1(int fanIndegree1);

    virtual int getSwitchIdentifier() const;
    virtual void setSwitchIdentifier(int switchIdentifier);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ATPPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ATPPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:129</tt> by opp_msgtool.
 * <pre>
 * class MTATPPacket extends AggPacket
 * {
 *     aggPolicy = MTATP;
 *     byteLength = 16 + 4;
 *     int timer;
 *     int aggCounter;
 *     bool flags[5];
 *     int treeCost;
 * }
 * </pre>
 */
class MTATPPacket : public ::AggPacket
{
  protected:
    int timer = 0;
    int aggCounter = 0;
    bool flags[5];
    int treeCost = 0;

  private:
    void copy(const MTATPPacket& other);

  protected:
    bool operator==(const MTATPPacket&) = delete;

  public:
    MTATPPacket(const char *name=nullptr);
    MTATPPacket(const MTATPPacket& other);
    virtual ~MTATPPacket();
    MTATPPacket& operator=(const MTATPPacket& other);
    virtual MTATPPacket *dup() const override {return new MTATPPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getTimer() const;
    virtual void setTimer(int timer);

    virtual int getAggCounter() const;
    virtual void setAggCounter(int aggCounter);

    virtual size_t getFlagsArraySize() const;
    virtual bool getFlags(size_t k) const;
    virtual void setFlags(size_t k, bool flags);

    virtual int getTreeCost() const;
    virtual void setTreeCost(int treeCost);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MTATPPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MTATPPacket& obj) {obj.parsimUnpack(b);}


namespace omnetpp {

template<> inline EthernetMacHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<EthernetMacHeader*>(ptr.get<cObject>()); }
template<> inline IpHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<IpHeader*>(ptr.get<cObject>()); }
template<> inline UdpHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<UdpHeader*>(ptr.get<cObject>()); }
template<> inline TcpLikeHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<TcpLikeHeader*>(ptr.get<cObject>()); }
template<> inline Packet *fromAnyPtr(any_ptr ptr) { return check_and_cast<Packet*>(ptr.get<cObject>()); }
template<> inline AggPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<AggPacket*>(ptr.get<cObject>()); }
template<> inline ATPPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<ATPPacket*>(ptr.get<cObject>()); }
template<> inline MTATPPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<MTATPPacket*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __PACKET_M_H

