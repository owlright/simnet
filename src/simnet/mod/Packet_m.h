//
// Generated file, do not edit! Created by opp_msgtool 6.0 from simnet/mod/Packet.msg.
//

#ifndef __PACKET_M_H
#define __PACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class EthernetMacHeader;
class IPv4Header;
class IPv6Header;
class SegmentRoutingHeader;
class Packet;
// cplusplus {{
#include <vector>
using omnetpp::opp_string;
// }}

/**
 * Enum generated from <tt>simnet/mod/Packet.msg:7</tt> by opp_msgtool.
 * <pre>
 * enum PacketType
 * {
 *     ACK = 0;
 *     DATA = 1;
 *     AGG = 2;
 *     REMIND = 3;
 *     MACK = 4; // multicast ack
 *     NOUSE = 5;
 * }
 * </pre>
 */
enum PacketType {
    ACK = 0,
    DATA = 1,
    AGG = 2,
    REMIND = 3,
    MACK = 4,
    NOUSE = 5
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PacketType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PacketType& e) { int n; b->unpack(n); e = static_cast<PacketType>(n); }

/**
 * Class generated from <tt>simnet/mod/Packet.msg:17</tt> by opp_msgtool.
 * <pre>
 * packet EthernetMacHeader
 * {
 *     byteLength = 14; // ! only this affects size
 *     uint32_t destinationMacAddr; // 6B
 *     uint32_t sourceMacAddr; // 6B
 *     uint32_t etherType; // 4B
 * 
 * }
 * </pre>
 */
class EthernetMacHeader : public ::omnetpp::cPacket
{
  protected:
    uint32_t destinationMacAddr = 0;
    uint32_t sourceMacAddr = 0;
    uint32_t etherType = 0;

  private:
    void copy(const EthernetMacHeader& other);

  protected:
    bool operator==(const EthernetMacHeader&) = delete;

  public:
    EthernetMacHeader(const char *name=nullptr, short kind=0);
    EthernetMacHeader(const EthernetMacHeader& other);
    virtual ~EthernetMacHeader();
    EthernetMacHeader& operator=(const EthernetMacHeader& other);
    virtual EthernetMacHeader *dup() const override {return new EthernetMacHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getDestinationMacAddr() const;
    virtual void setDestinationMacAddr(uint32_t destinationMacAddr);

    virtual uint32_t getSourceMacAddr() const;
    virtual void setSourceMacAddr(uint32_t sourceMacAddr);

    virtual uint32_t getEtherType() const;
    virtual void setEtherType(uint32_t etherType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EthernetMacHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EthernetMacHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:26</tt> by opp_msgtool.
 * <pre>
 * class IPv4Header extends EthernetMacHeader
 * {
 *     byteLength = 14 + 20;
 *     uint8_t version = 4; // 4 bits
 *     uint8_t IHL; // internet header length 4 bits
 *     uint8_t DSCP; // 6 bits
 *     uint8_t ipECN; // 2 bits
 *     uint16_t totalLength; // 2B
 *     uint8_t identification; // 2B
 *     uint8_t ipFlags; // 3 bits
 *     uint8_t fragmentOffset; // 13 bits;
 *     uint8_t TTL; // 1B
 *     uint8_t protocol; // 1B
 *     uint16_t checksum; // 2B
 *     int64_t srcAddr; // 4B
 *     int64_t destAddr; // 4B
 *     uint64_t options; // if IHL > 5
 * }
 * </pre>
 */
class IPv4Header : public ::EthernetMacHeader
{
  protected:
    uint8_t version = 4;
    uint8_t IHL = 0;
    uint8_t DSCP = 0;
    uint8_t ipECN = 0;
    uint16_t totalLength = 0;
    uint8_t identification = 0;
    uint8_t ipFlags = 0;
    uint8_t fragmentOffset = 0;
    uint8_t TTL = 0;
    uint8_t protocol = 0;
    uint16_t checksum = 0;
    int64_t srcAddr = 0;
    int64_t destAddr = 0;
    uint64_t options = 0;

  private:
    void copy(const IPv4Header& other);

  protected:
    bool operator==(const IPv4Header&) = delete;

  public:
    IPv4Header(const char *name=nullptr);
    IPv4Header(const IPv4Header& other);
    virtual ~IPv4Header();
    IPv4Header& operator=(const IPv4Header& other);
    virtual IPv4Header *dup() const override {return new IPv4Header(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getVersion() const;
    virtual void setVersion(uint8_t version);

    virtual uint8_t getIHL() const;
    virtual void setIHL(uint8_t IHL);

    virtual uint8_t getDSCP() const;
    virtual void setDSCP(uint8_t DSCP);

    virtual uint8_t getIpECN() const;
    virtual void setIpECN(uint8_t ipECN);

    virtual uint16_t getTotalLength() const;
    virtual void setTotalLength(uint16_t totalLength);

    virtual uint8_t getIdentification() const;
    virtual void setIdentification(uint8_t identification);

    virtual uint8_t getIpFlags() const;
    virtual void setIpFlags(uint8_t ipFlags);

    virtual uint8_t getFragmentOffset() const;
    virtual void setFragmentOffset(uint8_t fragmentOffset);

    virtual uint8_t getTTL() const;
    virtual void setTTL(uint8_t TTL);

    virtual uint8_t getProtocol() const;
    virtual void setProtocol(uint8_t protocol);

    virtual uint16_t getChecksum() const;
    virtual void setChecksum(uint16_t checksum);

    virtual int64_t getSrcAddr() const;
    virtual void setSrcAddr(int64_t srcAddr);

    virtual int64_t getDestAddr() const;
    virtual void setDestAddr(int64_t destAddr);

    virtual uint64_t getOptions() const;
    virtual void setOptions(uint64_t options);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IPv4Header& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IPv4Header& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:45</tt> by opp_msgtool.
 * <pre>
 * class IPv6Header extends EthernetMacHeader
 * {
 *     byteLength = 14 + 40;
 *     uint8_t version = 6; // 4 bits
 *     //    uint8_t trafficClass; // 8bits
 *     //    uint32_t flowLabel; // 20 bits
 *     //    uint16_t payloadLength; // 2B
 *     //    uint8_t nextHeader; // 1B
 *     //    uint8_t TTL; // 1B
 *     int64_t srcAddr; // 16B
 *     int64_t destAddr; // 16B
 * }
 * </pre>
 */
class IPv6Header : public ::EthernetMacHeader
{
  protected:
    uint8_t version = 6;
    int64_t srcAddr = 0;
    int64_t destAddr = 0;

  private:
    void copy(const IPv6Header& other);

  protected:
    bool operator==(const IPv6Header&) = delete;

  public:
    IPv6Header(const char *name=nullptr);
    IPv6Header(const IPv6Header& other);
    virtual ~IPv6Header();
    IPv6Header& operator=(const IPv6Header& other);
    virtual IPv6Header *dup() const override {return new IPv6Header(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getVersion() const;
    virtual void setVersion(uint8_t version);

    virtual int64_t getSrcAddr() const;
    virtual void setSrcAddr(int64_t srcAddr);

    virtual int64_t getDestAddr() const;
    virtual void setDestAddr(int64_t destAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IPv6Header& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IPv6Header& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:58</tt> by opp_msgtool.
 * <pre>
 * class SegmentRoutingHeader extends IPv6Header
 * {
 *     //    uint8_t nextHeader; // 1B
 *     uint8_t hdrLength; // Header extension length 1B
 *     uint8_t routingType; // 1B
 *     uint8_t segmentsLeft; // 1B
 *     uint8_t lastEntry; //1B
 *     uint8_t srhFlags; // 1B
 *     uint16_t srhTag; // 2B
 *     // below three are together segmentList each 16B
 *     int64_t segments[] \@custom \@sizeGetter \@sizeSetter;
 *     string funs[] \@custom \@sizeGetter \@sizeSetter; // tell the node what to do
 *     string args[] \@custom \@sizeGetter \@sizeSetter; // args of functions
 * }
 * </pre>
 */
class SegmentRoutingHeader : public ::IPv6Header
{
  protected:
    uint8_t hdrLength = 0;
    uint8_t routingType = 0;
    uint8_t segmentsLeft = 0;
    uint8_t lastEntry = 0;
    uint8_t srhFlags = 0;
    uint16_t srhTag = 0;

  private:
    void copy(const SegmentRoutingHeader& other);

  protected:
    bool operator==(const SegmentRoutingHeader&) = delete;

  public:
    SegmentRoutingHeader(const char *name=nullptr);
    SegmentRoutingHeader(const SegmentRoutingHeader& other);
    virtual ~SegmentRoutingHeader();
    SegmentRoutingHeader& operator=(const SegmentRoutingHeader& other);
    virtual SegmentRoutingHeader *dup() const override {return new SegmentRoutingHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getHdrLength() const;
    virtual void setHdrLength(uint8_t hdrLength);

    virtual uint8_t getRoutingType() const;
    virtual void setRoutingType(uint8_t routingType);

    virtual uint8_t getSegmentsLeft() const;
    virtual void setSegmentsLeft(uint8_t segmentsLeft);

    virtual uint8_t getLastEntry() const;
    virtual void setLastEntry(uint8_t lastEntry);

    virtual uint8_t getSrhFlags() const;
    virtual void setSrhFlags(uint8_t srhFlags);

    virtual uint16_t getSrhTag() const;
    virtual void setSrhTag(uint16_t srhTag);


	protected:
		std::vector<int64_t> segments; // intermediate node address
		std::vector<opp_string> funs;
		std::vector<opp_string> args;
	public:
		// expected methods:
		virtual void setSegmentsArraySize(size_t size) {segments.resize(size);}
		virtual void setFunsArraySize(size_t size) {funs.resize(size);}
		virtual void setArgsArraySize(size_t size) {args.resize(size);}

		virtual size_t getSegmentsArraySize() const {return segments.size();}
		virtual size_t getFunsArraySize() const {return funs.size();}
		virtual size_t getArgsArraySize() const {return args.size();}

		virtual int64_t getSegments(size_t k) {return segments.at(k);}
		virtual const opp_string& getFuns(size_t k) {return funs.at(k);}
		virtual const opp_string& getArgs(size_t k) {return args.at(k);}

		virtual void setSegments(size_t k, int64_t addr) {segments.at(k) = addr;}
		virtual void setFuns(size_t k, const char* fun) {funs.at(k) = fun;}
		virtual void setArgs(size_t k, const char* arg) {args.at(k) = arg;}

		// new methods:
		virtual void setSIDSize(size_t size) {
		    setSegmentsArraySize(size);
		    setFunsArraySize(size);
		    setArgsArraySize(size);
		}
		virtual void popSegment() {segments.pop_back();}
		virtual void popFun() {funs.pop_back();}
		virtual void popArg() {args.pop_back();}
        virtual const std::vector<int64_t>& getAllSegments() {return segments;}
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SegmentRoutingHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SegmentRoutingHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/Packet.msg:73</tt> by opp_msgtool.
 * <pre>
 * class Packet extends SegmentRoutingHeader
 * {
 *     // udp/tcp fields
 *     int64_t seqNumber;
 *     uint16_t localPort;
 *     uint16_t destPort;
 *     bool ECN;
 *     bool ECE;
 *     // cheating fields
 *     PacketType packetType;
 *     int64_t connectionId;
 *     int64_t receivedBytes;
 *     double startTime;
 *     double transmitTime;
 *     double queueTime;
 *     bool isFlowFinished;
 *     bool resend;
 *     int round;
 * }
 * </pre>
 */
class Packet : public ::SegmentRoutingHeader
{
  protected:
    int64_t seqNumber = 0;
    uint16_t localPort = 0;
    uint16_t destPort = 0;
    bool ECN = false;
    bool ECE = false;
    PacketType packetType = static_cast<PacketType>(-1);
    int64_t connectionId = 0;
    int64_t receivedBytes = 0;
    double startTime = 0;
    double transmitTime = 0;
    double queueTime = 0;
    bool isFlowFinished_ = false;
    bool resend = false;
    int round = 0;

  private:
    void copy(const Packet& other);

  protected:
    bool operator==(const Packet&) = delete;

  public:
    Packet(const char *name=nullptr);
    Packet(const Packet& other);
    virtual ~Packet();
    Packet& operator=(const Packet& other);
    virtual Packet *dup() const override {return new Packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int64_t getSeqNumber() const;
    virtual void setSeqNumber(int64_t seqNumber);

    virtual uint16_t getLocalPort() const;
    virtual void setLocalPort(uint16_t localPort);

    virtual uint16_t getDestPort() const;
    virtual void setDestPort(uint16_t destPort);

    virtual bool getECN() const;
    virtual void setECN(bool ECN);

    virtual bool getECE() const;
    virtual void setECE(bool ECE);

    virtual PacketType getPacketType() const;
    virtual void setPacketType(PacketType packetType);

    virtual int64_t getConnectionId() const;
    virtual void setConnectionId(int64_t connectionId);

    virtual int64_t getReceivedBytes() const;
    virtual void setReceivedBytes(int64_t receivedBytes);

    virtual double getStartTime() const;
    virtual void setStartTime(double startTime);

    virtual double getTransmitTime() const;
    virtual void setTransmitTime(double transmitTime);

    virtual double getQueueTime() const;
    virtual void setQueueTime(double queueTime);

    virtual bool isFlowFinished() const;
    virtual void setIsFlowFinished(bool isFlowFinished);

    virtual bool getResend() const;
    virtual void setResend(bool resend);

    virtual int getRound() const;
    virtual void setRound(int round);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Packet& obj) {obj.parsimUnpack(b);}


namespace omnetpp {

template<> inline EthernetMacHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<EthernetMacHeader*>(ptr.get<cObject>()); }
template<> inline IPv4Header *fromAnyPtr(any_ptr ptr) { return check_and_cast<IPv4Header*>(ptr.get<cObject>()); }
template<> inline IPv6Header *fromAnyPtr(any_ptr ptr) { return check_and_cast<IPv6Header*>(ptr.get<cObject>()); }
template<> inline SegmentRoutingHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<SegmentRoutingHeader*>(ptr.get<cObject>()); }
template<> inline Packet *fromAnyPtr(any_ptr ptr) { return check_and_cast<Packet*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __PACKET_M_H

