//
// Generated file, do not edit! Created by opp_msgtool 6.0 from simnet/mod/AggPacket.msg.
//

#ifndef __AGGPACKET_M_H
#define __AGGPACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class AggPacket;
class AggUseIncPacket;
class AggNoIncPacket;
#include "Packet_m.h" // import Packet

/**
 * Enum generated from <tt>simnet/mod/AggPacket.msg:4</tt> by opp_msgtool.
 * <pre>
 * enum AggPolicy
 * {
 *     NOINC = 0;
 *     INC = 1;
 * 
 * }
 * </pre>
 */
enum AggPolicy {
    NOINC = 0,
    INC = 1
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const AggPolicy& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, AggPolicy& e) { int n; b->unpack(n); e = static_cast<AggPolicy>(n); }

/**
 * Class generated from <tt>simnet/mod/AggPacket.msg:11</tt> by opp_msgtool.
 * <pre>
 * class AggPacket extends Packet
 * {
 *     packetType = AGG;
 *     AggPolicy aggPolicy = NOINC;
 *     int64_t jobId;
 *     int64_t aggSeqNumber;
 *     int workerNumber;
 *     int treeCost;
 *     int distance;
 *     // bool resend;
 *     bool isAck;
 *     // cheating fields
 *     int64_t workerRecord[] \@custom \@sizeGetter(getRecordLen) \@sizeSetter(setRecordLen) \@getter(getRecord) \@setter(setRecord);
 *     int receivedNumber;
 *     int64_t PSAddr;
 * }
 * </pre>
 */
class AggPacket : public ::Packet
{
  protected:
    AggPolicy aggPolicy = NOINC;
    int64_t jobId = 0;
    int64_t aggSeqNumber = 0;
    int workerNumber = 0;
    int treeCost = 0;
    int distance = 0;
    bool isAck_ = false;
    int receivedNumber = 0;
    int64_t PSAddr = 0;

  private:
    void copy(const AggPacket& other);

  protected:
    bool operator==(const AggPacket&) = delete;

  public:
    AggPacket(const char *name=nullptr);
    AggPacket(const AggPacket& other);
    virtual ~AggPacket();
    AggPacket& operator=(const AggPacket& other);
    virtual AggPacket *dup() const override {return new AggPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual AggPolicy getAggPolicy() const;
    virtual void setAggPolicy(AggPolicy aggPolicy);

    virtual int64_t getJobId() const;
    virtual void setJobId(int64_t jobId);

    virtual int64_t getAggSeqNumber() const;
    virtual void setAggSeqNumber(int64_t aggSeqNumber);

    virtual int getWorkerNumber() const;
    virtual void setWorkerNumber(int workerNumber);

    virtual int getTreeCost() const;
    virtual void setTreeCost(int treeCost);

    virtual int getDistance() const;
    virtual void setDistance(int distance);

    virtual bool isAck() const;
    virtual void setIsAck(bool isAck);

    virtual int getReceivedNumber() const;
    virtual void setReceivedNumber(int receivedNumber);

    virtual int64_t getPSAddr() const;
    virtual void setPSAddr(int64_t PSAddr);


    protected:
        std::vector<int64_t> workerRecord;
    public:
        // expected methods:
        virtual void setRecordLen(size_t size) {
            workerRecord.reserve(size);
        }
        virtual size_t getRecordLen() const {return workerRecord.size();}
        virtual std::vector<int64_t> getRecord() const {return workerRecord;}
        virtual int64_t getRecord(size_t k) {return workerRecord.at(k);}
        virtual void setRecord(size_t k, int64_t worker) {
            EV_WARN << "You should not use this method, but using addRecord instead." << std::endl;
            workerRecord[k] = worker;
        }
        //new methods:
        virtual void addRecord(int64_t worker) {
            workerRecord.push_back(worker);
        }
        virtual void setRecord(std::vector<int64_t>& workers) {
            auto oldLen = getRecordLen();
            for (auto i = 0; i < oldLen; i++) {
                workerRecord[i] = workers.back();
                workers.pop_back();
            }
            while (!workers.empty()) {
                workerRecord.push_back(workers.back());
                workers.pop_back();
            }
        }
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const AggPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, AggPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/AggPacket.msg:67</tt> by opp_msgtool.
 * <pre>
 * class AggUseIncPacket extends AggPacket
 * {
 *     unsigned long aggregatorIndex;
 *     bool collision;
 *     bool ecn;
 *     bool overflow;
 * 
 *     aggPolicy = INC;
 *     int aggCounter;
 * }
 * </pre>
 */
class AggUseIncPacket : public ::AggPacket
{
  protected:
    unsigned long aggregatorIndex = 0;
    bool collision = false;
    bool ecn = false;
    bool overflow = false;
    int aggCounter = 0;

  private:
    void copy(const AggUseIncPacket& other);

  protected:
    bool operator==(const AggUseIncPacket&) = delete;

  public:
    AggUseIncPacket(const char *name=nullptr);
    AggUseIncPacket(const AggUseIncPacket& other);
    virtual ~AggUseIncPacket();
    AggUseIncPacket& operator=(const AggUseIncPacket& other);
    virtual AggUseIncPacket *dup() const override {return new AggUseIncPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual unsigned long getAggregatorIndex() const;
    virtual void setAggregatorIndex(unsigned long aggregatorIndex);

    virtual bool getCollision() const;
    virtual void setCollision(bool collision);

    virtual bool getEcn() const;
    virtual void setEcn(bool ecn);

    virtual bool getOverflow() const;
    virtual void setOverflow(bool overflow);

    virtual int getAggCounter() const;
    virtual void setAggCounter(int aggCounter);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const AggUseIncPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, AggUseIncPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simnet/mod/AggPacket.msg:78</tt> by opp_msgtool.
 * <pre>
 * class AggNoIncPacket extends AggPacket
 * {
 *     aggPolicy = NOINC;
 * }
 * </pre>
 */
class AggNoIncPacket : public ::AggPacket
{
  protected:

  private:
    void copy(const AggNoIncPacket& other);

  protected:
    bool operator==(const AggNoIncPacket&) = delete;

  public:
    AggNoIncPacket(const char *name=nullptr);
    AggNoIncPacket(const AggNoIncPacket& other);
    virtual ~AggNoIncPacket();
    AggNoIncPacket& operator=(const AggNoIncPacket& other);
    virtual AggNoIncPacket *dup() const override {return new AggNoIncPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const AggNoIncPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, AggNoIncPacket& obj) {obj.parsimUnpack(b);}


namespace omnetpp {

template<> inline AggPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<AggPacket*>(ptr.get<cObject>()); }
template<> inline AggUseIncPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<AggUseIncPacket*>(ptr.get<cObject>()); }
template<> inline AggNoIncPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<AggNoIncPacket*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __AGGPACKET_M_H

